# Agentic Chat UI - Project Context for Claude

## Project Overview

This is a production-ready agentic chat interface that allows an AI assistant to respond with both streaming text AND rich interactive widgets. Think of it like OpenAI's ChatKit but model-agnostic and fully customizable.

## Key Design Decisions

### 1. Widget System Architecture

**Decision**: Use a registry-based plugin architecture for widgets.

**Rationale**:
- Easy to add new widgets without modifying core code
- Type-safe widget registration
- Supports both predefined and dynamic (VDOM) widgets
- Widgets are self-contained and reusable

**Implementation**:
```typescript
// Register a widget
WidgetRegistry.register('my_widget', MyWidgetComponent);

// Render a widget
<WidgetRenderer widget={widgetBlock} onAction={handleAction} />
```

### 2. VDOM System for Dynamic Widgets

**Decision**: Support VDOM-based widgets defined in JSON.

**Rationale**:
- Agent can create custom widgets without deploying new code
- Flexible composition of UI elements
- Limited to safe components (no arbitrary code execution)
- Maps to Ant Design components

**Example**:
```json
{
  "component": "Card",
  "props": { "title": "Weather" },
  "children": [
    { "component": "Text", "children": ["72°F"] },
    { "component": "Button", "props": { "action": "refresh" }, "children": ["Refresh"] }
  ]
}
```

### 3. SSE for Streaming

**Decision**: Use Server-Sent Events instead of WebSockets.

**Rationale**:
- Simpler protocol for one-way streaming
- Native browser support
- Automatic reconnection
- Works with standard HTTP infrastructure
- No need for WebSocket server setup

### 4. Shared Types Between Client and Server

**Decision**: Duplicate `protocol.ts` in both client and server.

**Rationale**:
- Each codebase is self-contained
- No monorepo complexity
- Easy to keep in sync (simple copy)
- Type safety on both ends

**Trade-off**: Need to manually sync types when protocol changes.

### 5. Action Feedback Loop

**Decision**: Widget actions send a new user message with action metadata.

**Rationale**:
- Keeps conversation context in message history
- Agent sees full interaction history
- Simple to implement
- Works with any LLM backend

**Flow**:
```
User clicks widget button → New message with widgetAction payload
→ Agent processes action → Responds with text/widgets
```

## Project Structure Explained

### Client (`client/src/`)

```
components/
├── Chat/                 # Core chat UI
│   ├── ChatSidebar.tsx   # Main container
│   ├── MessageList.tsx   # Scrollable messages
│   ├── MessageItem.tsx   # Single message + widgets
│   ├── ChatInput.tsx     # User input
│   └── StreamingText.tsx # Markdown + streaming cursor
├── Widgets/              # Widget system
│   ├── WidgetRegistry.ts      # Registry singleton
│   ├── WidgetRenderer.tsx     # Routes to components
│   ├── DynamicWidget.tsx      # VDOM renderer wrapper
│   └── predefined/            # Predefined widgets
│       ├── EmailPreviewWidget.tsx
│       ├── CalendarEventWidget.tsx
│       ├── SearchResultsWidget.tsx
│       ├── FormWidget.tsx
│       ├── MeetingCardWidget.tsx
│       └── FlightCardWidget.tsx
└── ErrorBoundary.tsx     # Catches widget errors

lib/
├── chat-client.ts        # SSE client
├── vdom-renderer.tsx     # VDOM → React
└── widget-schema.ts      # (future) JSON schema validation

hooks/
└── useChatAgent.ts       # Main chat logic hook

types/
├── protocol.ts           # Shared with server
└── messages.ts           # Client-only types
```

### Server (`server/src/`)

```
mock/
├── agent.ts              # Mock LLM agent
├── widgets.ts            # Widget data generators
└── scenarios.ts          # Trigger keywords → responses

routes/
└── chat.ts               # POST /api/chat endpoint

utils/
└── stream-helper.ts      # SSE utilities

types/
└── protocol.ts           # Shared with client
```

## How the Widget System Works

### 1. Widget Definition

Every widget has:
- `id`: Unique instance identifier
- `type`: Widget type (maps to component)
- `data`: Widget-specific data (strongly typed)
- `actions`: Optional user actions
- `vdom`: Optional VDOM for custom widgets

### 2. Widget Rendering

```typescript
// Server sends:
{ type: 'widget', widget: { id: 'w1', type: 'email_preview', data: {...} } }

// Client receives:
→ WidgetRenderer looks up 'email_preview' in registry
→ Renders EmailPreviewWidget with data
→ User clicks action → triggers onAction callback
→ New message sent with widgetAction payload
```

### 3. Widget Actions

Actions flow back to the agent:

```typescript
// User clicks "Reply" on email widget
onAction('reply', { emailId: '123' })

// Sends message:
{
  role: 'user',
  content: 'Performed action: reply',
  widgetAction: {
    widgetId: 'w1',
    actionType: 'reply',
    actionData: { emailId: '123' }
  }
}

// Agent sees action in history and responds accordingly
```

## API Protocol

### Request Format

```typescript
POST /api/chat

{
  messages: [
    { role: 'user', content: 'Find my emails' },
    { role: 'assistant', content: 'I found 3 emails...' },
    {
      role: 'user',
      content: 'Reply to first one',
      widgetAction: {
        widgetId: 'email-1',
        actionType: 'reply',
        actionData: {...}
      }
    }
  ],
  conversationId: 'conv-123'
}
```

### Response Format (SSE)

```typescript
// Stream of events:
data: {"type":"text_delta","content":"I found "}
data: {"type":"text_delta","content":"3 emails"}
data: {"type":"widget","widget":{...}}
data: {"type":"done"}
```

## Common Development Tasks

### Adding a New Widget Type

1. **Create widget component:**

```typescript
// client/src/components/Widgets/predefined/MyWidget.tsx
export const MyWidget: React.FC<WidgetProps> = ({ widget, onAction }) => {
  const data = widget.data as MyWidgetData;
  return <Card>...</Card>;
};
```

2. **Register widget:**

```typescript
// client/src/components/Widgets/predefined/index.ts
WidgetRegistry.register('my_widget', MyWidget);
```

3. **Add mock data generator:**

```typescript
// server/src/mock/widgets.ts
export function createMyWidget(): WidgetBlock {
  return {
    id: `my-${Date.now()}`,
    type: 'my_widget',
    data: {...}
  };
}
```

4. **Add scenario:**

```typescript
// server/src/mock/scenarios.ts
{
  keywords: ['show my widget'],
  response: {
    text: 'Here is your widget:',
    widgets: [createMyWidget()]
  }
}
```

### Modifying the Protocol

1. Update `server/src/types/protocol.ts`
2. Copy changes to `client/src/types/protocol.ts`
3. Update affected widgets/handlers
4. Test end-to-end

### Debugging Tips

**Streaming Issues:**
- Check browser Network tab → SSE connection
- Look for "text/event-stream" content type
- Verify data: prefix on each line

**Widget Not Rendering:**
- Check widget type is registered
- Look for errors in browser console
- Verify data shape matches widget interface
- Check ErrorBoundary for caught errors

**Action Not Working:**
- Verify onAction callback is passed down
- Check widgetAction payload in network request
- Look at server logs for received action

## Known Limitations

1. **No Persistence**: Messages stored in React state only
2. **No Authentication**: Mock server has no auth
3. **Limited VDOM Components**: Only supports select Ant Design components
4. **No Real LLM**: Mock agent uses keyword matching
5. **No Widget Versioning**: Breaking changes require manual migration
6. **No Streaming Retry**: If stream breaks, must restart conversation

## Future Enhancements

1. **Persistence**: Add localStorage or backend DB for conversations
2. **Real LLM Integration**: Replace mock agent with OpenAI/Claude API
3. **Widget Gallery**: Visual showcase of all widgets (partially done)
4. **Widget Marketplace**: Share and discover community widgets
5. **Schema Validation**: JSON schema for widget data
6. **Optimistic Updates**: Show loading states for actions
7. **Streaming Recovery**: Resume interrupted streams
8. **Voice Input**: Speech-to-text integration
9. **File Uploads**: Attach files to messages
10. **Multi-modal**: Support images in chat

## Testing Strategy

### Unit Tests (TODO)
- Widget components with mock data
- VDOM renderer edge cases
- Chat client SSE parsing
- Widget registry operations

### Integration Tests (TODO)
- Full message flow end-to-end
- Widget action feedback loop
- Error handling scenarios
- Stream interruption recovery

### Manual Testing Scenarios
- ✅ Send message and see streaming response
- ✅ Receive widgets in response
- ✅ Click widget actions
- ✅ Submit forms with validation
- ✅ Handle network errors
- ✅ Widget rendering errors (ErrorBoundary)
- ✅ Multiple widgets in one response
- ✅ Custom VDOM widgets

## Performance Considerations

1. **Message List**: Uses simple scrolling (virtualization TODO for 1000+ messages)
2. **Widget Memoization**: Widgets re-render on every message update (optimize with React.memo)
3. **Stream Buffering**: SSE events processed immediately (no debouncing)
4. **Component Lazy Loading**: Widgets loaded eagerly (code splitting TODO)

## Security Considerations

1. **VDOM Safety**: Limited component set prevents XSS
2. **Action Validation**: Server should validate all action payloads
3. **Content Sanitization**: Markdown renderer is XSS-safe
4. **CORS**: Configured for local dev only
5. **Rate Limiting**: Not implemented (TODO for production)

## Deployment Notes

### Production Checklist
- [ ] Add authentication
- [ ] Configure production CORS
- [ ] Add rate limiting
- [ ] Enable HTTPS
- [ ] Add monitoring/logging
- [ ] Optimize bundle size
- [ ] Add CDN for static assets
- [ ] Database for conversations
- [ ] Real LLM integration
- [ ] Error tracking (Sentry, etc.)

### Environment Variables

```bash
# Server
PORT=3001
NODE_ENV=production
LLM_API_KEY=xxx  # When using real LLM

# Client
VITE_API_URL=https://api.example.com
```

## Useful Commands

```bash
# Development
npm run dev              # Start dev server
npm run build            # Build for production
npm run preview          # Preview production build
npm run type-check       # Check TypeScript

# Debugging
npm run dev -- --debug   # Verbose logging
npm run dev -- --host    # Expose to network
```

## Contact & Resources

- **GitHub**: (Add your repo URL)
- **Docs**: See `docs/` folder
- **Issues**: (Add issue tracker URL)
- **Discord**: (Add community link)

---

**Last Updated**: 2024-02
**Version**: 1.0.0
**Maintainers**: Your Team
